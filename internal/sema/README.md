# Семантический анализ для rust2go

## Обзор

Модуль `sema` реализует семантический анализ для Rust-подобного языка, выполняющий проверки типов, разрешение символов и другие семантические проверки.

## Архитектура

### Основные компоненты

#### 1. Checker
Основная структура анализатора, содержащая:
- `errors` - список накопленных семантических ошибок
- `symbols` - глобальная таблица символов (функции, структуры)
- `currentFunction` - контекст для отладки

#### 2. Типы данных

**SemanticError** - семантическая ошибка с позицией в исходном коде

**Symbol** - представляет символ в таблице символов:
- `Kind` - категория символа (переменная, функция, структура)
- `Name` - имя символа
- `Type` - информация о типе
- `Pos` - позиция в исходном коде
- `Defined` - был ли символ определён
- `Function` - для функций: указатель на определение

**TypeInfo** - информация о типе:
- `Name` - имя типа (например, "i32", "String", "bool")
- `IsArray` - является ли тип массивом
- `IsReference` - является ли тип ссылкой

## Функциональность

### 1. Разрешение символов

Семантический анализатор строит таблицу символов и проверяет:
- Корректность имён переменных и функций
- Область видимости (локальная/глобальная)
- Отсутствие дублирующихся определений

### 2. Проверка типов

Выполняются следующие проверки:
- Соответствие типов в арифметических операциях
- Соответствие типов в операциях сравнения
- Соответствие типов в логических операциях
- Совместимость типов аргументов при вызове функций

#### Поддерживаемые типы

- Числовые: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`
- Булев: `bool`
- Строковые: `String`, `str`
- Unit тип: `()`

#### Вывод типов

Тип выводится из инициализатора при использовании `let` без явного указания типа:
```rust
let x = 5;  // x имеет тип i32
```

### 3. Проверка функций

- Проверка количества аргументов
- Проверка типов аргументов
- Проверка возвращаемых типов
- Проверка тела функции

### 4. Поддержка макросов

Встроенные макросы Rust (например, `println!`, `vec!`, `panic!`) обрабатываются особым образом:
- Макросы принимают произвольные аргументы
- Всегда возвращают тип `()`
- Не требуют явного определения

## Использование

```go
checker := sema.NewChecker()
errors := checker.Check(ast)

if len(errors) > 0 {
    for _, err := range errors {
        fmt.Println(err)
    }
}
```

## Интеграция

Семантический анализатор интегрирован в основной workflow после парсинга:

1. Лексический анализ
2. Синтаксический анализ (парсинг)
3. **Семантический анализ** ← здесь
4. Генерация кода (в будущем)

## Ограничения текущей реализации

1. Упрощённая модель типов (нет generic, trait, enum)
2. Нет контроля потока выполнения (if, while, match)
3. Нет проверки заимствований (borrow checker)
4. Нет анализа lifetime'ов
5. Макросы обрабатываются упрощённо

## Расширение в будущем

- Добавление поддержки generic типов
- Поддержка struct и их методов
- Контроль потока выполнения
- Анализ заимствований
- Проверка lifetime'ов

